// Generated by CoffeeScript 2.7.0
//###########################################################
// log = console.log
// olog = (arg) -> console.log(JSON.stringify(arg, null, 4))

//###########################################################
//region Basic Schema Type Enumeration

//###########################################################
//# Notice: NUMBER validation
// Due to JSON limitations NaN and (-)Infinity are invalid
// This means that NUMBER type already excludes these values
// Previously we had FINITENUMBER and NONANNUMBER 
// These types are gone now :-)
var ErrorToMessage, booleanOrNothingStringify, booleanOrNullStringify, booleanStringify, c, createArrayStringifier, createArrayValidator, createObjectStringifier, createObjectValidator, createStaticStringValidator, createThrower, dirtyCharMap, dirtyChars, domainCharMap, domainChars, getStringifierEntriesForObject, getTypeStringifier, getTypeStringifiersForArray, getTypeValidator, getTypeValidatorsForArray, getValidatorEntriesForObject, hexChars, hexMap, invalidEmailSmallRegex, isDirtyObject, j, l, len, len1, len2, locked, m, numberOrNothingStringify, numberOrNullStringify, numberStringify, numericOnlyRegex, objectOrNothingStringify, objectStringify, staticValidatorOrThrow, stringOrNothingStringify, stringOrNullStringify, stringStringify, typeArraySize, typeStringifierFunctions, typeValidatorFunctions;

export var BOOLEAN = 1;

export var NUMBER = 2;

export var ARRAY = 3;

export var OBJECT = 4;

export var STRING = 5;

export var STRINGEMAIL = 6;

export var STRINGHEX = 7;

export var STRINGHEX32 = 8;

export var STRINGHEX64 = 9;

export var STRINGHEX128 = 10;

export var STRINGHEX256 = 11;

export var STRINGHEX512 = 12;

export var STRINGCLEAN = 13;

export var NONEMPTYSTRING = 14;

export var NONEMPTYSTRINGHEX = 15;

export var NONEMPTYSTRINGCLEAN = 16;

export var NONEMPTYARRAY = 17;

export var OBJECTCLEAN = 18;

export var NONNULLOBJECT = 19;

export var NONNULLOBJECTCLEAN = 20;

export var STRINGORNOTHING = 21;

export var STRINGEMAILORNOTHING = 22;

export var STRINGHEXORNOTHING = 23;

export var STRINGHEX32ORNOTHING = 24;

export var STRINGHEX64ORNOTHING = 25;

export var STRINGHEX128ORNOTHING = 26;

export var STRINGHEX256ORNOTHING = 27;

export var STRINGHEX512ORNOTHING = 28;

export var STRINGCLEANORNOTHING = 29;

export var NUMBERORNOTHING = 30;

export var BOOLEANORNOTHING = 31;

export var ARRAYORNOTHING = 32;

export var OBJECTORNOTHING = 33;

export var OBJECTCLEANORNOTHING = 34;

export var STRINGORNULL = 35;

export var STRINGEMAILORNULL = 36;

export var STRINGHEXORNULL = 37;

export var STRINGHEX32ORNULL = 38;

export var STRINGHEX64ORNULL = 39;

export var STRINGHEX128ORNULL = 40;

export var STRINGHEX256ORNULL = 41;

export var STRINGHEX512ORNULL = 42;

export var STRINGCLEANORNULL = 43;

export var NUMBERORNULL = 44;

export var BOOLEANORNULL = 45;

export var ARRAYORNULL = 46;

typeArraySize = 47;

//endregion

//###########################################################
//region Local Variables
staticValidatorOrThrow = null;

locked = false;

//###########################################################
numericOnlyRegex = /^\d+$/;

invalidEmailSmallRegex = /(\.\.|--|-\.)|\.-/;

//###########################################################
hexChars = "0123456789abcdefABCDEF";

hexMap = Object.create(null);

for (j = 0, len = hexChars.length; j < len; j++) {
  c = hexChars[j];
  hexMap[c] = true;
}

// Object.freeze(hexMap) # creates minor performance penalty

//###########################################################
domainChars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-.";

domainCharMap = Object.create(null);

for (l = 0, len1 = domainChars.length; l < len1; l++) {
  c = domainChars[l];
  domainCharMap[c] = true;
}

// Object.freeze(domainCharMap) # creates minor performance penalty

//###########################################################
dirtyChars = "\x00\x01\x02\x03\x04\x05\x06\x07\x08" + "\x0B\x0C" + "\x0E\x0F\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1A\x1B\x1C\x1D\x1E\x1F" + "\x7F" + "\u00A0" + "\u1680" + "\u180E" + "\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A" + "\u200B\u200C\u200D\u200E\u200F" + "\u2028\u2029" + "\u202A\u202B\u202C\u202D\u202E" + "\u2060\u2061\u2062\u2063\u2064\u2066\u2067\u2068\u2069" + "\u3000" + "\uFEFF"; // ASCII control 0â€“8 // vertical tab, form feed // rest of controls // DEL // non-breaking space // ogham space mark // mongolian vowel separator // en/em/etc. spaces // zero-width spaces, joiners, directional // line/paragraph separators // embedding/override control // invisible controls // ideographic space

dirtyCharMap = Object.create(null);

for (m = 0, len2 = dirtyChars.length; m < len2; m++) {
  c = dirtyChars[m];
  dirtyCharMap[c] = true;
}

// Object.freeze(dirtyCharMap) # creates minor performance penalty

//endregion

//###########################################################
//region Local Functions

//###########################################################
isDirtyObject = function(obj) {
  var k, keys, len3, n;
  if (obj === null) {
    return;
  }
  //# as the inputs come from an object which was originalled paref from a JSON string we assume to not fall into an infinite loop
  keys = Object.keys(obj);
  for (n = 0, len3 = keys.length; n < len3; n++) {
    k = keys[n];
    if (k === "__proto__" || k === "constructor" || k === "prototype") {
      return true;
    }
    if (typeof obj[k] === "object") {
      if (isDirtyObject(obj[k])) {
        return true;
      }
    }
  }
  return false;
};

//###########################################################
createStaticStringValidator = function(str) {
  return function(arg) {
    if (arg !== str) {
      return ISINVALID;
    }
  };
};

createThrower = function(msg) {
  return function() {
    throw new Error(msg);
  };
};

//###########################################################
//region Validator Creation Helpers
getTypeValidator = function(type) {
  var fun;
  fun = typeValidatorFunctions[type];
  if (fun == null) {
    throw new Error(`Unrecognized Schematype! (${type})`);
  }
  return fun;
};

//###########################################################
getTypeValidatorsForArray = function(arr) {
  var el, funcs, i, len3, n;
  funcs = new Array(arr.length);
  for (i = n = 0, len3 = arr.length; n < len3; i = ++n) {
    el = arr[i];
    switch (false) {
      case typeof el !== "number":
        funcs[i] = getTypeValidator(el);
        break;
      case typeof el !== "string":
        funcs[i] = staticValidatorOrThrow(el);
        break;
      case typeof el === "object":
        throw new Error(`Illegal ${typeof el}!`);
      case !Array.isArray(el):
        funcs[i] = createArrayValidator(el);
        break;
      default:
        funcs[i] = createObjectValidator(el);
    }
  }
  return funcs;
};

getValidatorEntriesForObject = function(obj) {
  var entries, i, k, keys, len3, n, prop;
  keys = Object.keys(obj);
  entries = [];
  for (i = n = 0, len3 = keys.length; n < len3; i = ++n) {
    k = keys[i];
    prop = obj[k];
    if (typeof prop === "number") {
      entries.push([k, getTypeValidator(prop)]);
      continue;
    }
    if (typeof prop === "string") {
      entries.push([k, staticValidatorOrThrow(prop)]);
      continue;
    }
    if (typeof prop !== "object") {
      throw new Error(`Illegal ${typeof prop}!`);
    }
    if (Array.isArray(prop)) {
      entries.push([k, createArrayValidator(prop)]);
    } else {
      entries.push([k, createObjectValidator(prop)]);
    }
  }
  return entries;
};

//###########################################################
createArrayValidator = function(arr) {
  var func, funcs;
  if (arr.length === 0) {
    throw new Error("[] is illegal!");
  }
  funcs = getTypeValidatorsForArray(arr);
  // olog valEntries
  func = function(arg) {
    var el, err, f, hits, i, len3, n;
    if (!Array.isArray(arg)) {
      return ISINVALID;
    }
    hits = 0;
    for (i = n = 0, len3 = funcs.length; n < len3; i = ++n) {
      f = funcs[i];
      el = arg[i];
      if (el !== void 0) {
        hits++;
      }
      err = f(el);
      if (err) {
        return err;
      }
    }
    if (arg.length > hits) {
      return ISINVALID;
    }
  };
  return func;
};

createObjectValidator = function(obj) {
  var func, valEntries;
  // Obj is Schema Obj like obj = { prop1:STRING, prop2:NUMBER,... }
  if (obj === null) {
    throw new Error("null is illegal!");
  }
  valEntries = getValidatorEntriesForObject(obj);
  // olog valEntries
  if (valEntries.length === 0) {
    throw new Error("{} is illegal!");
  }
  func = function(arg) {
    var e, err, hits, keys, len3, n, prop;
    // log "validating Object!"
    // olog arg
    // log "valEntries.length: #{valEntries.length}"
    if (typeof arg !== "object") {
      return ISINVALID;
    }
    if (arg === null) {
      return ISINVALID;
    }
    hits = 0;
    for (n = 0, len3 = valEntries.length; n < len3; n++) {
      e = valEntries[n];
      // olog e
      prop = arg[e[0]];
      if (prop !== void 0) {
        hits++;
      }
      err = e[1](prop);
      if (err) {
        return err;
      }
    }
    keys = Object.keys(arg);
    // log "arg keys Length: #{keys.length} -> hits: #{hits}"
    if (keys.length > hits) {
      return ISINVALID;
    }
  };
  // log "is valid!"
  return func;
};

//endregion

//###########################################################
//region Stringifier Creation Helpers
getTypeStringifier = function(type) {
  var fun;
  fun = typeStringifierFunctions[type];
  if (fun == null) {
    throw new Error(`Unrecognized Schematype! (${type})`);
  }
  return fun;
};

//###########################################################
getTypeStringifiersForArray = function(arr) {
  var el, i, len3, n, ts, type;
  ts = new Array(arr.length); //# type stringifiers
  for (i = n = 0, len3 = arr.length; n < len3; i = ++n) {
    el = arr[i];
    type = typeof el;
    if (type === "number") {
      ts[i] = getTypeStringifier(el);
    }
    if (type === "string") {
      ts[i] = getTypeStringifier(STRING);
    }
    if (type !== "object") {
      continue;
    }
    if (Array.isArray(el)) {
      ts[i] = createArrayStringifier(el);
    } else {
      ts[i] = createObjectStringifier(el);
    }
  }
  return ts;
};

getStringifierEntriesForObject = function(obj) {
  var i, k, keys, len3, n, prop, ses, type;
  keys = Object.keys(obj);
  ses = new Array(keys.length); // stringifier entries 
  for (i = n = 0, len3 = keys.length; n < len3; i = ++n) {
    k = keys[i];
    prop = obj[k];
    type = typeof prop;
    if (type === "number") {
      ses[i] = [k, getTypeStringifier(prop)];
    }
    if (type === "string") {
      ses[i] = [k, getTypeStringifier(STRING)];
    }
    if (type !== "object") {
      continue;
    }
    if (Array.isArray(prop)) {
      sfes[i] = [k, createArrayStringifier(prop)];
    } else {
      ses[i] = [k, createObjectStringifier(prop)];
    }
  }
  return ses;
};

//###########################################################
createArrayStringifier = function(arr) {
  var bufLen, buffer, func, stringifyFunctions;
  stringifyFunctions = getTypeStringifiersForArray(arr);
  bufLen = stringifyFunctions.length;
  buffer = new Array(bufLen);
  func = function(arg) {
    var f, i, len3, len4, n, o, s, str;
    for (i = n = 0, len3 = stringifyFunctions.length; n < len3; i = ++n) {
      f = stringifyFunctions[i];
      //# stringify contents with predefined functions
      buffer[i] = f(arg[i]);
    }
    //# cut off undefined tail
    while (buffer[buffer.length - 1] === void 0 && buffer.length !== 0) {
      buffer.pop();
    }
    //# fast return on no content
    if (buffer.length === 0) {
      buffer.length = bufLen; // restore original size
      return '[]';
    }

    // undefined within the array turns to 'null'
    for (i = o = 0, len4 = buffer.length; o < len4; i = ++o) {
      s = buffer[i];
      if (s === void 0) {
        buffer[i] = 'null';
      }
    }
    str = '[' + buffer[0];
    i = 1;
    while (i < buffer.length) {
      str += ',' + buffer[i++];
    }
    buffer.length = bufLen; // restore original size
    str += ']';
    return str;
  };
  return func;
};

createObjectStringifier = function(obj) {
  var bufLen, buffer, func, sfEntries;
  sfEntries = getStringifierEntriesForObject(obj); // stringifer entries
  bufLen = sfEntries.length;
  buffer = new Array(bufLen);
  func = function(arg) {
    var el, i, len3, n, str;
    for (i = n = 0, len3 = sfEntries.length; n < len3; i = ++n) {
      el = sfEntries[i];
      buffer[i] = el[1](arg[el[0]]);
    }
    
    // log "0"
    str = '{';
    i = 0;
    while (str.length === 1 && i < bufLen) {
      if (buffer[i] != null) {
        str += '"' + sfEntries[i][0] + '":' + buffer[i];
      }
      i++;
    }
    
      // log "1"
    while (i < bufLen) {
      if (buffer[i] != null) {
        str += ',"' + sfEntries[i][0] + '":' + buffer[i];
      }
      i++;
    }
    // log "2"
    str += '}';
    return str;
  };
  return func;
};

//endregion

//###########################################################
//region Raw Type Stringifier Functions
booleanStringify = function(arg) {
  if (arg) {
    return 'true';
  } else {
    return 'false';
  }
};

booleanOrNothingStringify = function(arg) {
  if (arg === void 0) {
    return arg;
  }
  if (arg) {
    return 'true';
  } else {
    return 'false';
  }
};

booleanOrNullStringify = function(arg) {
  if (arg === null) {
    return 'null';
  }
  if (arg) {
    return 'true';
  } else {
    return 'false';
  }
};

numberStringify = function(arg) {
  return '' + arg;
};

numberOrNothingStringify = function(arg) {
  if (arg === void 0) {
    return arg;
  } else {
    return '' + arg;
  }
};

numberOrNullStringify = function(arg) {
  if (arg === null) {
    return 'null';
  } else {
    return '' + arg;
  }
};

stringStringify = function(arg) {
  var code, i;
  if (arg.length > 67) {
    return JSON.stringify(arg);
  }
  i = 0;
  while (i < arg.length) {
    code = arg.charCodeAt(i);
    if (code < 93 && (code < 0x20 || code === 0x5c || code === 0x22)) {
      return JSON.stringify(arg);
    }
    i++;
  }
  return '"' + arg + '"';
};

stringOrNothingStringify = function(arg) {
  if (arg === void 0) {
    return arg;
  } else {
    return stringStringify(arg);
  }
};

stringOrNullStringify = function(arg) {
  if (arg === null) {
    return 'null';
  } else {
    return stringStringify(arg);
  }
};

objectStringify = JSON.stringify;

objectOrNothingStringify = function(arg) {
  if (arg === void 0) {
    return arg;
  } else {
    return JSON.stringify(arg);
  }
};

//TODO? maybe create specific Array Stringify function?

//endregion

//endregion

//###########################################################
//region Type Validator Functions
typeValidatorFunctions = new Array(typeArraySize);

//###########################################################
//region Validator Functions For Basic Schema Types
typeValidatorFunctions[STRING] = function(arg) {
  if (typeof arg !== "string") {
    return NOTASTRING;
  }
};

typeValidatorFunctions[STRINGEMAIL] = function(arg) {
  var atPos, dotPos, i, lastPos, len3, n, tld;
  if (typeof arg !== "string") {
    return NOTASTRING;
  }
  if (arg.length > 320 || arg.length < 5) {
    return INVALIDSIZE;
  }
  if (invalidEmailSmallRegex.test(arg)) {
    return INVALIDEMAIL;
  }
  // if arg.indexOf("..") >= 0 then return INVALIDEMAIL
  // if arg.indexOf("--") >= 0 then return INVALIDEMAIL
  // if arg.indexOf("-.") >= 0 then return INVALIDEMAIL
  // if arg.indexOf(".-") >= 0 then return INVALIDEMAIL
  atPos = arg.indexOf("@");
  if (atPos <= 0 || atPos > 64 || (arg.length - atPos) < 4 || arg[0] === "." || arg[atPos - 1] === "." || arg[0] === "-" || arg[atPos - 1] === "-" || arg[atPos + 1] === "." || arg[atPos + 1] === "-") {
    return INVALIDEMAIL;
  }

  // if atPos <= 0 then return INVALIDEMAIL
// if atPos > 64 then return INVALIDEMAIL
// if arg[0] == "." or arg[atPos - 1] == "." then return INVALIDEMAIL
// if arg[0] == "-" or arg[atPos - 1] == "-" then return INVALIDEMAIL
// if arg[atPos + 1] == "." or arg[atPos + 1] == "-" then return INVALIDEMAIL
  for (i = n = 0, len3 = arg.length; n < len3; i = ++n) {
    c = arg[i];
    if (!(domainCharMap[c] || i === atPos || (i < atPos && (c === "+" || c === "_")))) {
      return INVALIDEMAIL;
    }
  }
  if (arg[arg.length - 1] === "." || arg[arg.length - 1] === "-") {
    return INVALIDEMAIL;
  }
  lastPos = atPos;
  dotPos = arg.indexOf(".", atPos + 1);
  if (dotPos < 0) {
    return INVALIDEMAIL;
  }
  while (dotPos > 0) {
    if ((dotPos - lastPos) > 63) {
      return INVALIDEMAIL;
    }
    lastPos = dotPos;
    dotPos = arg.indexOf(".", lastPos + 1);
  }
  tld = arg.slice(lastPos + 1);
  if (numericOnlyRegex.test(tld)) {
    return INVALIDEMAIL;
  }
};

typeValidatorFunctions[STRINGHEX] = function(arg) {
  var len3, n;
  if (typeof arg !== "string") {
    return NOTASTRING;
  }
  for (n = 0, len3 = arg.length; n < len3; n++) {
    c = arg[n];
    if (!hexMap[c]) {
      return INVALIDHEX;
    }
  }
};

typeValidatorFunctions[STRINGHEX32] = function(arg) {
  var len3, n;
  if (typeof arg !== "string") {
    return NOTASTRING;
  }
  if (arg.length !== 32) {
    return INVALIDSIZE;
  }
  for (n = 0, len3 = arg.length; n < len3; n++) {
    c = arg[n];
    if (!hexMap[c]) {
      return INVALIDHEX;
    }
  }
};

typeValidatorFunctions[STRINGHEX64] = function(arg) {
  var len3, n;
  if (typeof arg !== "string") {
    return NOTASTRING;
  }
  if (arg.length !== 64) {
    return INVALIDSIZE;
  }
  for (n = 0, len3 = arg.length; n < len3; n++) {
    c = arg[n];
    if (!hexMap[c]) {
      return INVALIDHEX;
    }
  }
};

typeValidatorFunctions[STRINGHEX128] = function(arg) {
  var len3, n;
  if (typeof arg !== "string") {
    return NOTASTRING;
  }
  if (arg.length !== 128) {
    return INVALIDSIZE;
  }
  for (n = 0, len3 = arg.length; n < len3; n++) {
    c = arg[n];
    if (!hexMap[c]) {
      return INVALIDHEX;
    }
  }
};

typeValidatorFunctions[STRINGHEX256] = function(arg) {
  var len3, n;
  if (typeof arg !== "string") {
    return NOTASTRING;
  }
  if (arg.length !== 256) {
    return INVALIDSIZE;
  }
  for (n = 0, len3 = arg.length; n < len3; n++) {
    c = arg[n];
    if (!hexMap[c]) {
      return INVALIDHEX;
    }
  }
};

typeValidatorFunctions[STRINGHEX512] = function(arg) {
  var len3, n;
  if (typeof arg !== "string") {
    return NOTASTRING;
  }
  if (arg.length !== 512) {
    return INVALIDSIZE;
  }
  for (n = 0, len3 = arg.length; n < len3; n++) {
    c = arg[n];
    if (!hexMap[c]) {
      return INVALIDHEX;
    }
  }
};

typeValidatorFunctions[NUMBER] = function(arg) {
  if (typeof arg !== "number") {
    return NOTANUMBER;
  }
  if (isNaN(arg)) {
    return ISNAN;
  }
  if (arg === 2e308 || arg === -2e308) {
    return ISNOTFINITE;
  }
};

typeValidatorFunctions[BOOLEAN] = function(arg) {
  if (typeof arg !== "boolean") {
    return NOTABOOLEAN;
  }
};

typeValidatorFunctions[ARRAY] = function(arg) {
  if (!Array.isArray(arg)) {
    return NOTANARRAY;
  }
};

typeValidatorFunctions[OBJECT] = function(arg) {
  if (typeof arg !== "object") {
    return NOTANOBJECT;
  }
};

typeValidatorFunctions[STRINGORNOTHING] = function(arg) {
  if (arg === void 0) {
    return;
  }
  if (typeof arg !== "string") {
    return NOTASTRING;
  }
};

typeValidatorFunctions[STRINGEMAILORNOTHING] = function(arg) {
  var atPos, dotPos, i, lastPos, len3, n, tld;
  if (arg === void 0) {
    return;
  }
  if (typeof arg !== "string") {
    return NOTASTRING;
  }
  if (arg.length > 320 || arg.length < 5) {
    return INVALIDSIZE;
  }
  if (invalidEmailSmallRegex.test(arg)) {
    return INVALIDEMAIL;
  }
  // if arg.indexOf("..") >= 0 then return INVALIDEMAIL
  // if arg.indexOf("--") >= 0 then return INVALIDEMAIL
  // if arg.indexOf("-.") >= 0 then return INVALIDEMAIL
  // if arg.indexOf(".-") >= 0 then return INVALIDEMAIL
  atPos = arg.indexOf("@");
  if (atPos <= 0 || atPos > 64 || (arg.length - atPos) < 4 || arg[0] === "." || arg[atPos - 1] === "." || arg[0] === "-" || arg[atPos - 1] === "-" || arg[atPos + 1] === "." || arg[atPos + 1] === "-") {
    return INVALIDEMAIL;
  }

  // if atPos <= 0 then return INVALIDEMAIL
// if atPos > 64 then return INVALIDEMAIL
// if arg[0] == "." or arg[atPos - 1] == "." then return INVALIDEMAIL
// if arg[0] == "-" or arg[atPos - 1] == "-" then return INVALIDEMAIL
// if arg[atPos + 1] == "." or arg[atPos + 1] == "-" then return INVALIDEMAIL
  for (i = n = 0, len3 = arg.length; n < len3; i = ++n) {
    c = arg[i];
    if (!(domainCharMap[c] || i === atPos || (i < atPos && (c === "+" || c === "_")))) {
      return INVALIDEMAIL;
    }
  }
  if (arg[arg.length - 1] === "." || arg[arg.length - 1] === "-") {
    return INVALIDEMAIL;
  }
  lastPos = atPos;
  dotPos = arg.indexOf(".", atPos + 1);
  if (dotPos < 0) {
    return INVALIDEMAIL;
  }
  while (dotPos > 0) {
    if ((dotPos - lastPos) > 63) {
      return INVALIDEMAIL;
    }
    lastPos = dotPos;
    dotPos = arg.indexOf(".", lastPos + 1);
  }
  tld = arg.slice(lastPos + 1);
  if (numericOnlyRegex.test(tld)) {
    return INVALIDEMAIL;
  }
};

typeValidatorFunctions[STRINGHEXORNOTHING] = function(arg) {
  var len3, n;
  if (arg === void 0) {
    return;
  }
  if (typeof arg !== "string") {
    return NOTASTRING;
  }
  for (n = 0, len3 = arg.length; n < len3; n++) {
    c = arg[n];
    if (!hexMap[c]) {
      return INVALIDHEX;
    }
  }
};

typeValidatorFunctions[STRINGHEX32ORNOTHING] = function(arg) {
  var len3, n;
  if (arg === void 0) {
    return;
  }
  if (typeof arg !== "string") {
    return NOTASTRING;
  }
  if (arg.length !== 32) {
    return INVALIDSIZE;
  }
  for (n = 0, len3 = arg.length; n < len3; n++) {
    c = arg[n];
    if (!hexMap[c]) {
      return INVALIDHEX;
    }
  }
};

typeValidatorFunctions[STRINGHEX64ORNOTHING] = function(arg) {
  var len3, n;
  if (arg === void 0) {
    return;
  }
  if (typeof arg !== "string") {
    return NOTASTRING;
  }
  if (arg.length !== 64) {
    return INVALIDSIZE;
  }
  for (n = 0, len3 = arg.length; n < len3; n++) {
    c = arg[n];
    if (!hexMap[c]) {
      return INVALIDHEX;
    }
  }
};

typeValidatorFunctions[STRINGHEX128ORNOTHING] = function(arg) {
  var len3, n;
  if (arg === void 0) {
    return;
  }
  if (typeof arg !== "string") {
    return NOTASTRING;
  }
  if (arg.length !== 128) {
    return INVALIDSIZE;
  }
  for (n = 0, len3 = arg.length; n < len3; n++) {
    c = arg[n];
    if (!hexMap[c]) {
      return INVALIDHEX;
    }
  }
};

typeValidatorFunctions[STRINGHEX256ORNOTHING] = function(arg) {
  var len3, n;
  if (arg === void 0) {
    return;
  }
  if (typeof arg !== "string") {
    return NOTASTRING;
  }
  if (arg.length !== 256) {
    return INVALIDSIZE;
  }
  for (n = 0, len3 = arg.length; n < len3; n++) {
    c = arg[n];
    if (!hexMap[c]) {
      return INVALIDHEX;
    }
  }
};

typeValidatorFunctions[STRINGHEX512ORNOTHING] = function(arg) {
  var len3, n;
  if (arg === void 0) {
    return;
  }
  if (typeof arg !== "string") {
    return NOTASTRING;
  }
  if (arg.length !== 512) {
    return INVALIDSIZE;
  }
  for (n = 0, len3 = arg.length; n < len3; n++) {
    c = arg[n];
    if (!hexMap[c]) {
      return INVALIDHEX;
    }
  }
};

typeValidatorFunctions[NUMBERORNOTHING] = function(arg) {
  if (arg === void 0) {
    return;
  }
  if (typeof arg !== "number") {
    return NOTANUMBER;
  }
  if (isNaN(arg)) {
    return ISNAN;
  }
  if (arg === 2e308 || arg === -2e308) {
    return ISNOTFINITE;
  }
};

typeValidatorFunctions[BOOLEANORNOTHING] = function(arg) {
  if (arg === void 0) {
    return;
  }
  if (typeof arg !== "boolean") {
    return NOTABOOLEAN;
  }
};

typeValidatorFunctions[ARRAYORNOTHING] = function(arg) {
  if (arg === void 0) {
    return;
  }
  if (!Array.isArray(arg)) {
    return NOTANARRAY;
  }
};

typeValidatorFunctions[OBJECTORNOTHING] = function(arg) {
  if (arg === void 0) {
    return;
  }
  if (typeof arg !== "object") {
    return NOTANOBJECT;
  }
};

typeValidatorFunctions[STRINGORNULL] = function(arg) {
  if (arg === null) {
    return;
  }
  if (typeof arg !== "string") {
    return NOTASTRING;
  }
};

typeValidatorFunctions[STRINGEMAILORNULL] = function(arg) {
  var atPos, dotPos, i, lastPos, len3, n, tld;
  if (arg === null) {
    return;
  }
  if (typeof arg !== "string") {
    return NOTASTRING;
  }
  if (arg.length > 320 || arg.length < 5) {
    return INVALIDSIZE;
  }
  if (invalidEmailSmallRegex.test(arg)) {
    return INVALIDEMAIL;
  }
  // if arg.indexOf("..") >= 0 then return INVALIDEMAIL
  // if arg.indexOf("--") >= 0 then return INVALIDEMAIL
  // if arg.indexOf("-.") >= 0 then return INVALIDEMAIL
  // if arg.indexOf(".-") >= 0 then return INVALIDEMAIL
  atPos = arg.indexOf("@");
  if (atPos <= 0 || atPos > 64 || (arg.length - atPos) < 4 || arg[0] === "." || arg[atPos - 1] === "." || arg[0] === "-" || arg[atPos - 1] === "-" || arg[atPos + 1] === "." || arg[atPos + 1] === "-") {
    return INVALIDEMAIL;
  }

  // if atPos <= 0 then return INVALIDEMAIL
// if atPos > 64 then return INVALIDEMAIL
// if arg[0] == "." or arg[atPos - 1] == "." then return INVALIDEMAIL
// if arg[0] == "-" or arg[atPos - 1] == "-" then return INVALIDEMAIL
// if arg[atPos + 1] == "." or arg[atPos + 1] == "-" then return INVALIDEMAIL
  for (i = n = 0, len3 = arg.length; n < len3; i = ++n) {
    c = arg[i];
    if (!(domainCharMap[c] || i === atPos || (i < atPos && (c === "+" || c === "_")))) {
      return INVALIDEMAIL;
    }
  }
  if (arg[arg.length - 1] === "." || arg[arg.length - 1] === "-") {
    return INVALIDEMAIL;
  }
  lastPos = atPos;
  dotPos = arg.indexOf(".", atPos + 1);
  if (dotPos < 0) {
    return INVALIDEMAIL;
  }
  while (dotPos > 0) {
    if ((dotPos - lastPos) > 63) {
      return INVALIDEMAIL;
    }
    lastPos = dotPos;
    dotPos = arg.indexOf(".", lastPos + 1);
  }
  tld = arg.slice(lastPos + 1);
  if (numericOnlyRegex.test(tld)) {
    return INVALIDEMAIL;
  }
};

typeValidatorFunctions[STRINGHEXORNULL] = function(arg) {
  var len3, n;
  if (arg === null) {
    return;
  }
  if (typeof arg !== "string") {
    return NOTASTRING;
  }
  for (n = 0, len3 = arg.length; n < len3; n++) {
    c = arg[n];
    if (!hexMap[c]) {
      return INVALIDHEX;
    }
  }
};

typeValidatorFunctions[STRINGHEX32ORNULL] = function(arg) {
  var len3, n;
  if (arg === null) {
    return;
  }
  if (typeof arg !== "string") {
    return NOTASTRING;
  }
  if (arg.length !== 32) {
    return INVALIDSIZE;
  }
  for (n = 0, len3 = arg.length; n < len3; n++) {
    c = arg[n];
    if (!hexMap[c]) {
      return INVALIDHEX;
    }
  }
};

typeValidatorFunctions[STRINGHEX64ORNULL] = function(arg) {
  var len3, n;
  if (arg === null) {
    return;
  }
  if (typeof arg !== "string") {
    return NOTASTRING;
  }
  if (arg.length !== 64) {
    return INVALIDSIZE;
  }
  for (n = 0, len3 = arg.length; n < len3; n++) {
    c = arg[n];
    if (!hexMap[c]) {
      return INVALIDHEX;
    }
  }
};

typeValidatorFunctions[STRINGHEX128ORNULL] = function(arg) {
  var len3, n;
  if (arg === null) {
    return;
  }
  if (typeof arg !== "string") {
    return NOTASTRING;
  }
  if (arg.length !== 128) {
    return INVALIDSIZE;
  }
  for (n = 0, len3 = arg.length; n < len3; n++) {
    c = arg[n];
    if (!hexMap[c]) {
      return INVALIDHEX;
    }
  }
};

typeValidatorFunctions[STRINGHEX256ORNULL] = function(arg) {
  var len3, n;
  if (arg === null) {
    return;
  }
  if (typeof arg !== "string") {
    return NOTASTRING;
  }
  if (arg.length !== 256) {
    return INVALIDSIZE;
  }
  for (n = 0, len3 = arg.length; n < len3; n++) {
    c = arg[n];
    if (!hexMap[c]) {
      return INVALIDHEX;
    }
  }
};

typeValidatorFunctions[STRINGHEX512ORNULL] = function(arg) {
  var len3, n;
  if (arg === null) {
    return;
  }
  if (typeof arg !== "string") {
    return NOTASTRING;
  }
  if (arg.length !== 512) {
    return INVALIDSIZE;
  }
  for (n = 0, len3 = arg.length; n < len3; n++) {
    c = arg[n];
    if (!hexMap[c]) {
      return INVALIDHEX;
    }
  }
};

typeValidatorFunctions[NUMBERORNULL] = function(arg) {
  if (arg === null) {
    return;
  }
  if (typeof arg !== "number") {
    return NOTANUMBER;
  }
  if (isNaN(arg)) {
    return ISNAN;
  }
  if (arg === 2e308 || arg === -2e308) {
    return ISNOTFINITE;
  }
};

typeValidatorFunctions[BOOLEANORNULL] = function(arg) {
  if (arg === null) {
    return;
  }
  if (typeof arg !== "boolean") {
    return NOTABOOLEAN;
  }
};

typeValidatorFunctions[ARRAYORNULL] = function(arg) {
  if (arg === null) {
    return;
  }
  if (!Array.isArray(arg)) {
    return NOTANARRAY;
  }
};

typeValidatorFunctions[NONNULLOBJECT] = function(arg) {
  if (typeof arg !== "object") {
    return NOTANOBJECT;
  }
  if (arg === null) {
    return ISNULL;
  }
};

typeValidatorFunctions[NONEMPTYSTRING] = function(arg) {
  if (typeof arg !== "string") {
    return NOTASTRING;
  }
  if (arg.length === 0) {
    return ISEMPTYSTRING;
  }
};

typeValidatorFunctions[NONEMPTYARRAY] = function(arg) {
  if (!Array.isArray(arg)) {
    return NOTANARRAY;
  }
  if (arg.length === 0) {
    return ISEMPTYARRAY;
  }
};

typeValidatorFunctions[NONEMPTYSTRINGHEX] = function(arg) {
  var len3, n;
  if (typeof arg !== "string") {
    return NOTASTRING;
  }
  if (arg.length === 0) {
    return ISEMPTYSTRING;
  }
  for (n = 0, len3 = arg.length; n < len3; n++) {
    c = arg[n];
    if (!hexMap[c]) {
      return INVALIDHEX;
    }
  }
};

typeValidatorFunctions[NONEMPTYSTRINGCLEAN] = function(arg) {
  var len3, n;
  if (typeof arg !== "string") {
    return NOTASTRING;
  }
  if (arg.length === 0) {
    return ISEMPTYSTRING;
  }
  for (n = 0, len3 = arg.length; n < len3; n++) {
    c = arg[n];
    if (dirtyCharMap[c]) {
      return ISDIRTYSTRING;
    }
  }
};

typeValidatorFunctions[STRINGCLEAN] = function(arg) {
  var len3, n;
  if (typeof arg !== "string") {
    return NOTASTRING;
  }
  for (n = 0, len3 = arg.length; n < len3; n++) {
    c = arg[n];
    if (dirtyCharMap[c]) {
      return ISDIRTYSTRING;
    }
  }
};

typeValidatorFunctions[STRINGCLEANORNULL] = function(arg) {
  var len3, n;
  if (arg === null) {
    return;
  }
  if (typeof arg !== "string") {
    return NOTASTRING;
  }
  for (n = 0, len3 = arg.length; n < len3; n++) {
    c = arg[n];
    if (dirtyCharMap[c]) {
      return ISDIRTYSTRING;
    }
  }
};

typeValidatorFunctions[STRINGCLEANORNOTHING] = function(arg) {
  var len3, n;
  if (arg === void 0) {
    return;
  }
  if (typeof arg !== "string") {
    return NOTASTRING;
  }
  for (n = 0, len3 = arg.length; n < len3; n++) {
    c = arg[n];
    if (dirtyCharMap[c]) {
      return ISDIRTYSTRING;
    }
  }
};

typeValidatorFunctions[OBJECTCLEAN] = function(arg) {
  if (typeof arg !== "object") {
    return NOTANOBJECT;
  }
  if (isDirtyObject(arg)) {
    return ISDIRTYOBJECT;
  }
};

typeValidatorFunctions[NONNULLOBJECTCLEAN] = function(arg) {
  if (typeof arg !== "object") {
    return NOTANOBJECT;
  }
  if (arg === null) {
    return ISNULL;
  }
  if (isDirtyObject(arg)) {
    return ISDIRTYOBJECT;
  }
};

typeValidatorFunctions[OBJECTCLEANORNOTHING] = function(arg) {
  if (arg === void 0) {
    return;
  }
  if (typeof arg !== "object") {
    return NOTANOBJECT;
  }
  if (isDirtyObject(arg)) {
    return ISDIRTYOBJECT;
  }
};

//endregion

//endregion

//###########################################################
//region Stringifier Functions
typeStringifierFunctions = new Array(typeArraySize);

//###########################################################
//region Stringify Functions for Schema Types
typeStringifierFunctions[STRING] = stringStringify;

typeStringifierFunctions[STRINGEMAIL] = stringStringify;

typeStringifierFunctions[STRINGHEX] = stringStringify;

typeStringifierFunctions[STRINGHEX32] = stringStringify;

typeStringifierFunctions[STRINGHEX64] = stringStringify;

typeStringifierFunctions[STRINGHEX128] = stringStringify;

typeStringifierFunctions[STRINGHEX256] = stringStringify;

typeStringifierFunctions[STRINGHEX512] = stringStringify;

typeStringifierFunctions[NUMBER] = numberStringify;

typeStringifierFunctions[BOOLEAN] = booleanStringify;

typeStringifierFunctions[ARRAY] = objectStringify;

typeStringifierFunctions[OBJECT] = objectStringify;

typeStringifierFunctions[STRINGORNOTHING] = stringOrNothingStringify;

typeStringifierFunctions[STRINGEMAILORNOTHING] = stringOrNothingStringify;

typeStringifierFunctions[STRINGHEXORNOTHING] = stringOrNothingStringify;

typeStringifierFunctions[STRINGHEX32ORNOTHING] = stringOrNothingStringify;

typeStringifierFunctions[STRINGHEX64ORNOTHING] = stringOrNothingStringify;

typeStringifierFunctions[STRINGHEX128ORNOTHING] = stringOrNothingStringify;

typeStringifierFunctions[STRINGHEX256ORNOTHING] = stringOrNothingStringify;

typeStringifierFunctions[STRINGHEX512ORNOTHING] = stringOrNothingStringify;

typeStringifierFunctions[NUMBERORNOTHING] = numberOrNothingStringify;

typeStringifierFunctions[BOOLEANORNOTHING] = booleanOrNothingStringify;

typeStringifierFunctions[ARRAYORNOTHING] = objectOrNothingStringify;

typeStringifierFunctions[OBJECTORNOTHING] = objectOrNothingStringify;

typeStringifierFunctions[STRINGORNULL] = stringOrNullStringify;

typeStringifierFunctions[STRINGEMAILORNULL] = stringOrNullStringify;

typeStringifierFunctions[STRINGHEXORNULL] = stringOrNullStringify;

typeStringifierFunctions[STRINGHEX32ORNULL] = stringOrNullStringify;

typeStringifierFunctions[STRINGHEX64ORNULL] = stringOrNullStringify;

typeStringifierFunctions[STRINGHEX128ORNULL] = stringOrNullStringify;

typeStringifierFunctions[STRINGHEX256ORNULL] = stringOrNullStringify;

typeStringifierFunctions[STRINGHEX512ORNULL] = stringOrNullStringify;

typeStringifierFunctions[NUMBERORNULL] = numberOrNullStringify;

typeStringifierFunctions[BOOLEANORNULL] = booleanOrNullStringify;

typeStringifierFunctions[ARRAYORNULL] = objectStringify;

typeStringifierFunctions[NONNULLOBJECT] = objectStringify;

typeStringifierFunctions[NONEMPTYSTRING] = stringStringify;

typeStringifierFunctions[NONEMPTYARRAY] = objectStringify;

typeStringifierFunctions[NONEMPTYSTRINGHEX] = stringStringify;

typeStringifierFunctions[NONEMPTYSTRINGCLEAN] = stringStringify;

typeStringifierFunctions[STRINGCLEAN] = stringStringify;

typeStringifierFunctions[STRINGCLEANORNULL] = stringOrNullStringify;

typeStringifierFunctions[STRINGCLEANORNOTHING] = stringOrNothingStringify;

typeStringifierFunctions[OBJECTCLEAN] = objectStringify;

typeStringifierFunctions[NONNULLOBJECTCLEAN] = objectStringify;

typeStringifierFunctions[OBJECTCLEANORNOTHING] = objectStringify;

//endregion

//endregion

//###########################################################
//region Error Codes and Messages
export var NOTASTRING = 1000;

export var NOTANUMBER = 1001;

export var NOTABOOLEAN = 1002;

export var NOTANARRAY = 1003;

export var NOTANOBJECT = 1004;

export var INVALIDHEX = 1005;

export var INVALIDEMAIL = 1006;

export var INVALIDSIZE = 1007;

export var ISNAN = 1008;

export var ISNULL = 1009;

export var ISEMPTYSTRING = 1010;

export var ISEMPTYARRAY = 1011;

export var ISDIRTYSTRING = 1012;

export var ISDIRTYOBJECT = 1013;

export var ISNOTFINITE = 1014;

export var ISINVALID = 2222;

// export THISERROR = 2223

//###########################################################
ErrorToMessage = Object.create(null);

ErrorToMessage[NOTASTRING] = "Not a String!";

ErrorToMessage[NOTANUMBER] = "Not a Number!";

ErrorToMessage[NOTABOOLEAN] = "Not a Boolean!";

ErrorToMessage[NOTANARRAY] = "Not an Array!";

ErrorToMessage[NOTANOBJECT] = "Not an Object!";

ErrorToMessage[INVALIDHEX] = "String is not valid hex!";

ErrorToMessage[INVALIDEMAIL] = "String is not a valid email!";

ErrorToMessage[INVALIDSIZE] = "String size mismatch!";

ErrorToMessage[ISNAN] = "Number is NaN!";

ErrorToMessage[ISNULL] = "Object is null!";

ErrorToMessage[ISEMPTYSTRING] = "String is empty!";

ErrorToMessage[ISEMPTYARRAY] = "Array is empty!";

ErrorToMessage[ISDIRTYSTRING] = "String is dirty!";

ErrorToMessage[ISDIRTYOBJECT] = "Object is dirty!";

ErrorToMessage[ISNOTFINITE] = "Number is not finite!";

ErrorToMessage[ISINVALID] = "Is invalid!";

// ErrorToMessage[THISERROR] = "This was the Error!"
//endregion

//###########################################################
//region API = exports
export var validate = function(obj, schema, staticStrings) {
  var type;
  if (staticStrings === true) {
    staticValidatorOrThrow = createStaticStringValidator;
  } else {
    staticValidatorOrThrow = createThrower("Static string!");
  }
  type = typeof schema;
  if (type === "number") {
    return getTypeValidator(schema)(obj);
  }
  if (type === "string") {
    return staticValidatorOrThrow(schema)(obj);
  }
  if (type !== "object") {
    throw new Error(`Illegal ${typeof schema}!`);
  }
  if (Array.isArray(schema)) {
    return createArrayValidator(schema)(obj);
  } else {
    return createObjectValidator(schema)(obj);
  }
};

//###########################################################
//# takes schema and optional boolean staticStrings
//#    a truthy staticStrings allows you to put static 
//#    strings into your schema like: 
//#    {userInpput: STRING, publicAccess: "onlywithexactlythisstring"}
//# returns the validator function
export var createValidator = function(schema, staticStrings) {
  var type;
  if (staticStrings === true) {
    staticValidatorOrThrow = createStaticStringValidator;
  } else {
    staticValidatorOrThrow = createThrower("Static string!");
  }
  type = typeof schema;
  if (type === "number") {
    return getTypeValidator(schema);
  }
  if (type === "string") {
    return staticValidatorOrThrow(schema);
  }
  if (type !== "object") {
    throw new Error(`Illegal ${typeof schema}!`);
  }
  if (Array.isArray(schema)) {
    return createArrayValidator(schema);
  } else {
    return createObjectValidator(schema);
  }
};

//###########################################################
//# takes errorcode
//# returns the associated errorMessage or ""
export var getErrorMessage = function(errorCode) {
  var msg;
  msg = ErrorToMessage[errorCode];
  if (typeof msg !== "string") {
    return "";
  } else {
    return msg;
  }
};

//###########################################################
//# takes a validatorFunction and getTypeStringifier
//#    this function cannot overwrite predefined types 
//# returns the new enumeration number for the defined Type
export var defineNewType = function(validatorFunc, stringifyFunc) {
  var newTypeId;
  if (locked) {
    throw new Error("We are closed!");
  }
  newTypeId = typeValidatorFunctions.length;
  if (newTypeId >= 1000) {
    throw new Error("Exeeding type limit!");
  }
  typeValidatorFunctions[newTypeId] = validatorFunc;
  typeStringifierFunctions[newTypeId] = stringifyFunc;
  return newTypeId;
};

//###########################################################
//# takes errorCode and errorMessage
//#     this function cannot overwrite predefined ErrorCodes
//# returns the new errorCode for the defined Error
export var defineNewError = function(errorMessage) {
  var errorCode;
  if (locked) {
    throw new Error("We are closed!");
  }
  errorCode = Object.keys(ErrorToMessage).length + 1000;
  if (errorCode >= 2000) {
    throw new Error("Exeeding error code limit!");
  }
  if (typeof errorMessage !== "string") {
    throw new Error("ErrorMessage not a String!");
  }
  ErrorToMessage[errorCode] = errorMessage;
  return errorCode;
};

//###########################################################
//# takes a type, validatorFunc and stringifyFunc
//#     sets the specified functions as validator and stringifier 
//#     for the given type
export var setTypeFunctions = function(type, valiatorFunc, stringifyFunc) {
  if (locked) {
    throw new Error("We are closed!");
  }
  if (typeof type !== "number") {
    throw new Error("type is not a Number!");
  }
  if (type >= typeValidatorFunctions.length || type < 1) {
    throw new Error("Type does not exist!");
  }
  if ((valiatorFunc != null) && typeof valiatorFunc !== "function") {
    throw new Error("validatorFunc is not a Function!");
  }
  if ((stringifyFunc != null) && typeof stringifyFunc !== "function") {
    throw new Error("stringifyFunc is not a Function!");
  }
  if (typeof validatorFunction !== "undefined" && validatorFunction !== null) {
    typeValidatorFunctions[type] = validatorFunc;
  } else {
    typeValidatorFunctions[type] = function() {};
  }
  if (stringifyFunc != null) {
    typeStringifierFunctions[type] = stringifyFunc;
  } else {
    typeStringifierFunctions[type] = function() {
      return "";
    };
  }
};


//###########################################################
//# locks/freezes all internal maps no mutation after this!
export var lock = function() {
  locked = true;
  Object.freeze(typeValidatorFunctions);
  Object.freeze(typeStringifierFunctions);
  Object.freeze(ErrorToMessage);
};

//endregion
